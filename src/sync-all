#!/usr/bin/env bash
set -euo pipefail

cd "$(git rev-parse --show-toplevel)"

echo ""
echo "ğŸ” Checking submodules..."
git submodule foreach '
    echo "ğŸ“¦ $name"
    cd "$toplevel/$sm_path"

    head_commit=$(git rev-parse HEAD)
    base_commit=$(git -C "$toplevel" ls-tree HEAD "$sm_path" | awk "{print \$3}")

    if ! git diff-index --quiet HEAD --; then
        echo "  ğŸ“ Uncommitted changes in working directory"
        git status --short
        read -p "  â†’ Commit and push changes? [Y/n] " confirm
        confirm=${confirm:-y}
        if [[ $confirm =~ ^[Yy]$ ]]; then
            git add .
            read -p "  â†’ Commit message: " msg
            git commit -m "${msg:-Update $name}"
            git push
            head_commit=$(git rev-parse HEAD) # update after push
        fi
    else
        echo "  âœ… Working tree clean"
    fi

    # Recheck base vs submodule pointer
    base_commit=$(git -C "$toplevel" ls-tree HEAD "$sm_path" | awk "{print \$3}")
    head_commit=$(git rev-parse HEAD)

    if [[ "$base_commit" != "$head_commit" ]]; then
        echo "  ğŸ”„ Base repo pointer is outdated for $name"
        echo "     Base has:  $base_commit"
        echo "     Submod is: $head_commit"
        echo "  ğŸ’¡ Run: git add $sm_path   # in base repo"
    else
        echo "  ğŸ”— Base pointer is up-to-date"
    fi
'

echo ""
echo "ğŸ” Checking base repo status..."
# 1. Check if working tree has changes (tracked or untracked)
if [[ -n $(git status --porcelain) ]]; then
	echo "âš ï¸ Base repo has changes:"
	git status --short
	read -rp "Stage and commit base repo changes? [y/N] " confirm
	if [[ $confirm =~ ^[Yy]$ ]]; then
		git add -A
		read -rp "Enter commit message: " msg
		git commit -m "${msg:-"Sync base repo changes"}"
	fi
else
	echo "âœ… Base repo is clean."
fi

echo ""
echo "â¬†ï¸  Final base repo push?"
read -rp "Push base repo now? [y/N] " push_confirm
if [[ $push_confirm =~ ^[Yy]$ ]]; then
	git push
	echo "âœ… All pushed."
else
	echo "â— Remember to push later: git push"
fi
